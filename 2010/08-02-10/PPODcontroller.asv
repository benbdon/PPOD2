function handles = PPODcontroller(handles)

plateAccSignals = handles.globalinfo.plateAccSignals;
plateAccLocalSignals = handles.globalinfo.plateAccLocalSignals;
actuatorAccSignals = handles.globalinfo.actuatorAccSignals;

N = handles.controllerinfo.cyclesPerUpdate;
NTC = handles.controllerinfo.numTransientCycles;
NCC = handles.controllerinfo.numCollectedCycles;
NPC = handles.controllerinfo.numProcessingCycles;
maxUpdate = handles.controllerinfo.maxUpdate;

samplesPerCycle = handles.signalinfo.samplesPerCycle;
T = handles.plateinfo.T;
f1 = sym(1/T);

%get matrix converting L to W to frame
A = handles.calibrationinfo.A;

%volts per m/s^2 calibration
V_per_ms2 = handles.calibrationinfo.V_per_ms2;

%specify how many samples to collect upon trigger
handles.daqinfo.ai.SamplesPerTrigger = NCC*samplesPerCycle;

controlledFreqs = handles.controllerinfo.controlledFreqs;
F = handles.controllerinfo.F;
FInd_all = find(ismember(F,controlledFreqs));
FInd_all = [FInd_all, fliplr(FInd_all)];
G_u2acc = handles.controllerinfo.G_u2acc;

k = handles.controllerinfo.k;

controllerUpdatesPerPlot = 1;

%get adesCyc and uCyc signals
adesCyc = handles.signalinfo.adesCyc;
uCyc = handles.signalinfo.uCyc;

%fft NCC cycles of desired plate motion signals
adesNCC_fft = fft(repmat(adesCyc,[NCC,1]));

%fft NCC cycles of uCyc
uNCC_fft = fft(repmat(uCyc,[NCC,1]));

%make sure u_fft is zero for frequencies above maxharmonic*basefreq
uNCC_fft = uNCC_fft + 2;
controlledHarmonics = handles.controllerinfo.controlledHarmonics;
fftInd_all = zeros(1,2*numel(controlledHarmonics));
for i = 1:numel(controlledHarmonics)
    harmonic = controlledHarmonics(i);
    fftInd_all(i) = NCC*harmonic+1;
    fftInd_all(end-i+1) = NCC*(samplesPerCycle-harmonic)+1;
end
uNCC_fft(~ismember(1:NCC*samplesPerCycle,fftInd_all),:) = 0;

%determine if initial control signals must change
tag = get(get(handles.initialcontrol,'selectedobject'),'tag');
switch tag
    case 'guess'
        for i = 1:length(fftInd_all)
            fftInd = fftInd_all(i);
            FInd = FInd_all(i);
            uNCC_fft(fftInd,:) = (squeeze(G_u2acc(:,:,FInd))\adesNCC_fft(fftInd,:).').';
            
            %reset uCyc (1 cycle)
            uNCC = ifft(uNCC_fft);
            uCyc = uNCC(1:samplesPerCycle,:);
        end

    case 'zero'
        uCyc = 0*uCyc;
        uNCC_fft = 0*uNCC_fft;
    case 'previous'
        set(handles.initialcontrol,'selectedobject',1)
end


%create N cycles of uCyc.
uN = repmat(uCyc ,[N,1]);

%create clock ao signal with trigger just before cycle NTC
clock = 0*uN(:,1);
clock(NTC*samplesPerCycle) = 5;


%INITIALIZES TRIGGER SIGNAL FOR CAMERA**********************************
%***********************************************************************
%create trigger signal for camera (goes low for 1ms at the beginning of
%each cycle)
cam_trig_1cyc = 5+zeros(samplesPerCycle,1);
cam_trig = repmat(cam_trig_1cyc, [N 1]);
samples_per_millisec = round(1/T*samplesPerCycle*1e-3);
delay = 0;
if samples_per_millisec < samplesPerCycle
    for i = 1:N
        delay = mod(delay,samplesPerCycle);
        startind = delay + 1 + samplesPerCycle*(i-1);
        endind = startind + samples_per_millisec;
        delta = samplesPerCycle - (endind-i*samplesPerCycle); %check to see if pulse goes into the next cycle
        if delta > 0 %this is good--pulse stays in 1 cycle
            cam_trig(startind:endind) = 0;
        else
            cam_trig(i*samplesPerCycle:i*samplesPerCycle-delta)=0 ;cam_trig(startind:samplesPerCycle*i) = 0;
        end
        delay = delay + 1;
    end
else
    error('Frequency of plate motion too high to capture images every cycle')
end
%**************************************************************************
%**************************************************************************

%put u_ao_init and clock_init into the queue
putdata(handles.daqinfo.ao, [clock, uN, cam_trig])

%start analog intput device (set to log during trigger event and then stops
%once data has been logged)
start(handles.daqinfo.ai)

%start analog output device (sends out data immediately)
start(handles.daqinfo.ao)

currentUpdate = 0;
set(handles.controllerupdates,'string',num2str(currentUpdate))

while currentUpdate < maxUpdate && get(handles.run,'value')
    
    %make sure there are still samples left in queue for ao to output. if
    %there are no more samples then the ao device will be "off" and must be restarted.
    while get(handles.daqinfo.ao,'samplesavailable') < samplesPerCycle*(NCC+NPC)
        putdata(handles.daqinfo.ao, [clock, uN, cam_trig])
        if strcmp(get(handles.daqinfo.ao,'Running'), 'Off')
            start(handles.daqinfo.ao)
        end
    end
    
    %wait for data to be collected from analog input (the device stops once
    %the data is logged)
    wait(handles.daqinfo.ai,5) %HARD CODED WAIT TIME--MODIFY???
    
    %import NCC cycles of accelerometer signals.  columns of aidata
    %correspond to ai_channel_names (i.e., sp1, sp2, sp3, sp4, pl1x, pl1y,
    %pl2x, pl2y)
    aidata_raw = getdata(handles.daqinfo.ai);
    meanaidata_raw = mean(aidata_raw);
    aidata = 1/V_per_ms2*(aidata_raw - repmat(meanaidata_raw,[size(aidata_raw,1),1]));
    
    %put aidata into signal matrices
    NPALS = numel(plateAccLocalSignals);
    NAAS = numel(actuatorAccSignals);
    aLocalNCC = aidata(:,1:NPALS);
    dddNCC = aidata(:,NPALS+1:NPALS+NAAS);
    
    %convert raw acceleration signals in local frames into plate
    %acceleration in W frame
    aNCC =(A\aLocalNCC')';
    
    %fft y_ai
    aNCC_fft = fft(aNCC);
    
    %desired acceleration
    for i = 1:numel(plateAccSignals)
        if ~strcmp(handles.plateinfo.adesChar, eval(['get(handles.',plateAccSignals{i},',''string'')']))
            adesCycUpdater(handles,
            
            adesCyc = handles.signalinfo.adesCyc;
            adesNCC_fft = fft(repmat(adesCyc,[NCC,1]));
        end
    end
    
    %compute error
    eNCC_fft = adesNCC_fft - aNCC_fft;
    
    %update ffts of control signals.
    for i = 1:length(fftInd_all)
        fftInd = fftInd_all(i);
        FInd = FInd_all(i);
        
        %apply iterative control law at each frequency
        deltauNCC_fft = (G_u2acc(:,:,FInd)\eNCC_fft(fftInd,:).').';
        uNCC_fft(fftInd,:) = uNCC_fft(fftInd,:) + k*deltauNCC_fft;
    end
    
    
    %get uCyc (1 cycle) and u_ao (N cycles)
    uNCC = ifft(uNCC_fft);
    uCyc = uNCC(1:samplesPerCycle,:);
    
    %check to make sure that uCyc does not exceed saturation voltage.  on
    %indices where it does, replace those voltages with +/-saturation
    %voltage
    signuCyc = sign(uCyc);
    uMax = handles.controllerinfo.uMax*ones(size(uCyc));
    ind = find(abs(uCyc) > uMax);
    uCyc(ind) = signuCyc(ind).*uMax(ind);
    
    %make N cycles of uCyc to send to analog out.
    uN = repmat(uCyc,[N,1]);
    
    %update camera trigger signal****************************************
    %********************************************************************
    %reinitialize cam_trig signal
    cam_trig_1cyc = 5+zeros(samplesPerCycle,1);
    cam_trig = repmat(cam_trig_1cyc, [N 1]);
    for i = 1:N
        delay = mod(delay,samplesPerCycle);
        startind = delay + 1 + samplesPerCycle*(i-1);
        endind = startind + samples_per_millisec;
        delta = samplesPerCycle - (endind-i*samplesPerCycle); %check to see if pulse goes into the next cycle
        if delta > 0 %this is good--pulse stays in 1 cycle
            if endind > numel(cam_trig)
                endind = numel(cam_trig);
            end
            cam_trig(startind:endind) = 0;
        else
            cam_trig(i*samplesPerCycle:i*samplesPerCycle-delta)=0 ;cam_trig(startind:samplesPerCycle*i) = 0;
        end
        delay = delay + 1;
    end
    %**********************************************************************
    %**********************************************************************
    
    %put new u_ao into queue
    putdata(handles.daqinfo.ao, [clock, uN, cam_trig])
    
    %restart analog input device
    start(handles.daqinfo.ai)
    
    %put signals back into handles
    handles.signalinfo.aCyc = aNCC(1:samplesPerCycle,:);
    handles.signalinfo.aLocalCyc = aLocalNCC(1:samplesPerCycle,:);
    handles.signalinfo.uCyc = uCyc;
    handles.signalinfo.dddCyc = dddNCC(1:samplesPerCycle,:);
    
    %plot data in GUI
    if mod(currentUpdate,controllerUpdatesPerPlot) == 0
        PlotControls(handles)
        PlotAccSignals(handles)
    end
    currentUpdate = currentUpdate + 1;
    handles.globalinfo.currentUpdate = currentUpdate;
    set(handles.controllerupdates,'string',num2str(currentUpdate))
    
end

stop(handles.daqinfo.ai)
stop(handles.daqinfo.ao)

set(handles.run,'value',0,'string','Run')


